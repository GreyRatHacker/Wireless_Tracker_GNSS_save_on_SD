<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-g">
    <title>GPSHack - Satelliten Visualisierung</title>
    <link rel="stylesheet" href="style.css">
    <style>
        /* Füge das hinzu, um den Lade-Text zu zentrieren */
        #loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            font-family: Arial, sans-serif;
        }
    </style>
</head>
<body>

    <div id="loader">Lade 3D-Modelle und Satelliten-Daten (TLEs)...</div>

    <div id="info-box">
        <h3>GPSHack Live Loop</h3>
        <p><strong>Zeit (aus DB):</strong> <span id="info-time">...</span></p>
        <p><strong>Position:</strong> <span id="info-pos">...</span></p>
        <p><strong>Tracker Sats (Gesehen):</strong> <span id="info-sats-seen">...</span></p>
        <p><strong>Alle Sats (Berechnet):</strong> <span id="info-sats-total">...</span></p>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164/examples/jsm/"
            }
        }
    </script>

    <script src="https://cdn.jsdelivr.net/npm/satellite.js@4.1.5/dist/satellite.min.js"></script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Globale Variablen ---
        let scene, camera, renderer, controls, earthMesh, trackerMesh;
        const loader = new GLTFLoader();
        const loaderElement = document.getElementById('loader');

        // Speichert alle Satelliten-Objekte (key = NORAD ID)
        const allSatellites = {}; 
        // Speichert alle TLEs (key = NORAD ID)
        const allTLEs = {};
        
        // Der Zähler für den 24h-Loop
        let loopIndex = 0;
        let lastFrameTime = 0;
        const loopSpeed = 50; // Loop-Geschwindigkeit (1 = 1 Sek/Sek, 50 = 50x schneller)

        // TLE-Datenquellen
        const TLE_SOURCES = [
            'https://cors-proxy.raab.workers.dev/?https://celestrak.org/NORAD/elements/gp.php?GROUP=gps-ops&FORMAT=tle',
            'https://cors-proxy.raab.workers.dev/?https://celestrak.org/NORAD/elements/gp.php?GROUP=glo-ops&FORMAT=tle',
            'https://cors-proxy.raab.workers.dev/?https://celestrak.org/NORAD/elements/gp.php?GROUP=galileo&FORMAT=tle',
            'https://cors-proxy.raab.workers.dev/?https://celestrak.org/NORAD/elements/gp.php?GROUP=beidou&FORMAT=tle'
        ];
        
        // Farb-Mapping für Systeme
        const SAT_COLORS = {
            'GP': 0x00ff00, // GPS = Grün
            'GL': 0xff0000, // GLONASS = Rot
            'GA': 0x0000ff, // Galileo = Blau
            'BD': 0xffff00, // BeiDou = Gelb
            'QZ': 0xffa500, // QZSS = Orange
            'DEFAULT': 0x555555 // Nicht gesehen = Grau
        };

        // --- Start ---
        init();

        // --- 1. Initialisierung der 3D-Szene ---
        async function init() {
            scene = new THREE.Scene();
            
            // Kamera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 30;

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Steuerung (Kamera bewegen)
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // Licht
            scene.add(new THREE.AmbientLight(0x404040, 1.5)); // Weiches Grundlicht
            
            // --- SONNE (Tag/Nacht-Linie) ---
            const sunLight = new THREE.DirectionalLight(0xffffff, 3.0);
            sunLight.position.set(100, 0, 50); // Position der "Sonne"
            scene.add(sunLight);

            // --- Lade TLEs, 3D-Modelle und starte den Loop ---
            try {
                await loadAllTLEs();
                await loadModels();
                loaderElement.style.display = 'none'; // Lade-Text ausblenden
                animate(); // Haupt-Loop starten
            } catch (error) {
                loaderElement.innerText = "Fehler beim Laden: " + error.message;
                console.error(error);
            }
        }

        // --- 2. Lade 3D-Modelle (Erde, Satellit) ---
        async function loadModels() {
            const earthTexture = new THREE.TextureLoader().load('earth_day.jpg'); // Du brauchst ein Bild der Erde
            
            // --- Erde ---
            const earthGeometry = new THREE.SphereGeometry(10, 64, 64);
            const earthMaterial = new THREE.MeshPhongMaterial({ map: earthTexture });
            earthMesh = new THREE.Mesh(earthGeometry, earthMaterial);
            
            // --- Der Jahreszeiten-Trick (Erdneigung) ---
            earthMesh.rotation.z = THREE.MathUtils.degToRad(23.5);
            scene.add(earthMesh);

            // --- Tracker (Dein Standort) ---
            // Wir erstellen einen kleinen Punkt für den Tracker
            const trackerGeometry = new THREE.SphereGeometry(0.1, 16, 16);
            const trackerMaterial = new THREE.MeshBasicMaterial({ color: 0xff00ff }); // Pink
            trackerMesh = new THREE.Mesh(trackerGeometry, trackerMaterial);
            scene.add(trackerMesh); // Position wird in updateScene() gesetzt

            // --- Satelliten ---
            // Wir erstellen alle Satelliten-Objekte (kleine Kugeln)
            const satGeometry = new THREE.SphereGeometry(0.08, 8, 8); // Kleinere Kugel
            for (const noradId in allTLEs) {
                const satData = allTLEs[noradId];
                
                // Grundfarbe ist Grau (nicht gesehen)
                const satMaterial = new THREE.MeshBasicMaterial({ color: SAT_COLORS.DEFAULT });
                const satMesh = new THREE.Mesh(satGeometry, satMaterial);
                
                // Speichere das 3D-Objekt und die Daten
                allSatellites[noradId] = {
                    mesh: satMesh,
                    material: satMaterial,
                    system: satData.system // "GP", "GL", etc.
                };
                scene.add(satMesh);
            }
            document.getElementById('info-sats-total').innerText = Object.keys(allSatellites).length;
        }

        // --- 3. Lade alle TLE-Daten von CelesTrak ---
        async function loadAllTLEs() {
            console.log("Lade TLEs von CelesTrak...");
            // Wir benutzen eine Proxy, um CORS-Fehler zu umgehen
            const proxyUrl = 'https://api.allorigins.win/raw?url=';
            
            // TLE-Quellen parallel laden
            const promises = TLE_SOURCES.map(url => fetch(proxyUrl + encodeURIComponent(url)).then(res => res.text()));
            const tleStrings = await Promise.all(promises);

            let count = 0;
            for (const tleText of tleStrings) {
                const lines = tleText.split('\n');
                for (let i = 0; i < lines.length - 2; i += 3) {
                    const tleLine0 = lines[i].trim();
                    const tleLine1 = lines[i + 1].trim();
                    const tleLine2 = lines[i + 2].trim();
                    
                    if (tleLine1.length > 0 && tleLine2.length > 0) {
                        const noradId = tleLine2.substring(2, 7); // NORAD ID
                        
                        // System-Typ aus dem Namen ableiten
                        let system = "GP"; // Standard
                        if (tleLine0.startsWith("GLONASS")) system = "GL";
                        else if (tleLine0.startsWith("GALILEO")) system = "GA";
                        else if (tleLine0.startsWith("BEIDOU")) system = "BD";
                        else if (tleLine0.startsWith("QZSS")) system = "QZ";
                        
                        // TLE-Datensatz im Speicher ablegen
                        allTLEs[noradId] = {
                            tle1: tleLine1,
                            tle2: tleLine2,
                            system: system
                        };
                        count++;
                    }
                }
            }
            console.log(`Laden abgeschlossen: ${count} TLEs gefunden.`);
        }

        // --- 4. Der Haupt-Loop (Animation & Datenabruf) ---
        function animate(timestamp) {
            requestAnimationFrame(animate);

            // Loop-Index basierend auf der Zeit erhöhen (damit es flüssig läuft)
            const deltaTime = (timestamp - lastFrameTime) || 0;
            lastFrameTime = timestamp;
            loopIndex += (deltaTime / 1000) * loopSpeed; // / 1000 = in Sekunden

            // --- Daten von PHP abrufen (ca. jede Sekunde) ---
            // (Wir runden den Index, um nicht 60x pro Sekunde PHP aufzurufen)
            const currentSecondIndex = Math.floor(loopIndex);
            if (currentSecondIndex !== window.lastRequestedIndex) {
                window.lastRequestedIndex = currentSecondIndex;
                
                // Rufe den Datensatz für den aktuellen Zeit-Index ab
                fetch(`get_data.php?index=${currentSecondIndex}`)
                    .then(res => res.json())
                    .then(data => {
                        if (data.gps) {
                            updateScene(data); // Szene mit neuen Daten aktualisieren
                        }
                    })
                    .catch(console.error);
            }
            
            controls.update();
            renderer.render(scene, camera);
        }

        // --- 5. Szene aktualisieren (Positionen, Farben, etc.) ---
        function updateScene(data) {
            const gps = data.gps;
            const satellitesSeen = data.satellites_seen_by_tracker;

            // --- Aktuelle Uhrzeit aus der Datenbank holen ---
            // Das ist der "Taktgeber" für die gesamte Simulation
            const now = new Date(gps.datetime + "Z"); // "Z" für UTC

            // --- Erde rotieren (Tag/Nacht-Linie) ---
            // Berechne, wie viel Uhr es ist (in % des Tages) und rotiere die Erde
            const gmst = satellite.gstime(now);
            earthMesh.rotation.y = gmst;

            // --- Tracker-Position aktualisieren ---
            const trackerPos = latLonToVector3(gps.lat, gps.lon, 10.1); // 10.1 = Radius + 0.1
            trackerMesh.position.copy(trackerPos);

            // --- ALLE Satelliten-Positionen berechnen & färben ---
            
            // 1. Alle Satelliten zurücksetzen (auf Grau)
            for (const noradId in allSatellites) {
                allSatellites[noradId].material.color.set(SAT_COLORS.DEFAULT);
            }

            // 2. Satelliten färben, die der Tracker "sieht"
            const seenNoradIds = {};
            for (const sat of satellitesSeen) {
                // Finde den NORAD-Code für diesen Satelliten
                // HINWEIS: Das ist eine Vereinfachung. 
                // NMEA-ID (sat.id) ist NICHT NORAD-ID.
                // Für ein echtes Projekt müsstest du eine Mapping-Tabelle (PRN -> NORAD) nutzen.
                // Wir färben hier einfach basierend auf dem System.
                
                // TODO: Hier fehlt das Mapping von sat.id -> noradId
                
                // Wir färben einfach *alle* Sats des gesehenen Systems
                for (const noradId in allSatellites) {
                    if (allSatellites[noradId].system === sat.system) {
                         allSatellites[noradId].material.color.set(SAT_COLORS[sat.system] || 0xffffff);
                    }
                }
            }

            // 3. Positionen ALLER Satelliten für "now" berechnen
            for (const noradId in allTLEs) {
                const tle = allTLEs[noradId];
                const satrec = satellite.twoline2satrec(tle.tle1, tle.tle2);
                
                // Position und Geschwindigkeit berechnen
                const posAndVel = satellite.propagate(satrec, now);
                const positionEci = posAndVel.position; // ECI-Koordinaten (km)

                if (positionEci) {
                    // ECI-Koordinaten (erdzentriert, fix) in
                    // ECF-Koordinaten (erdzentriert, rotierend) umwandeln
                    const gmst = satellite.gstime(now);
                    const positionEcf = satellite.eciToEcf(positionEci, gmst);
                    
                    // Skalieren für unsere 3D-Szene (10 = Erdradius)
                    // Geteilt durch 6371 (echter Erdradius in km)
                    const scalar = 10 / 6371; 
                    
                    const satMesh = allSatellites[noradId].mesh;
                    // WICHTIG: satellite.js nutzt Y als "oben", Three.js Z als "oben" (je nach Modell)
                    // Wir müssen Achsen tauschen: Z -> Y, Y -> Z
                    satMesh.position.set(
                        positionEcf.x * scalar,
                        positionEcf.z * scalar, // Achsen getauscht
                        positionEcf.y * scalar  // Achsen getauscht
                    );
                }
            }

            // --- Info-Kasten aktualisieren ---
            document.getElementById('info-time').innerText = gps.datetime;
            document.getElementById('info-pos').innerText = `${gps.lat}, ${gps.lon}`;
            document.getElementById('info-sats-seen').innerText = `${gps.sats_in_use} / ${gps.sats_in_view}`;
        }

        // --- Hilfsfunktion: Lat/Lon zu 3D-Vektor ---
        function latLonToVector3(lat, lon, radius) {
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lon + 180) * (Math.PI / 180);

            const x = -(radius * Math.sin(phi) * Math.cos(theta));
            const z = (radius * Math.sin(phi) * Math.sin(theta));
            const y = (radius * Math.cos(phi));

            return new THREE.Vector3(x, y, z);
        }

        // Fenstergröße anpassen
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
